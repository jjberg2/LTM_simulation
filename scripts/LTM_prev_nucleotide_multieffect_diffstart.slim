initialize() {

	initializeSLiMOptions(nucleotideBased=T);
	defineConstant('Ls', asInteger(liaSmall));   // input liaSmall
	defineConstant('Ll', asInteger(liaLarge));   // input liaLarge
	defineConstant('betaS', aS);  //input aS
   defineConstant('betaL', aL);  //input aL
	defineConstant('rhoS', floor(rhos * 10000)/10000);

	
	
	// set parameters
	perSiteMutRate = mu;  // input mu 
	perSiteRecRate = 30 * perSiteMutRate; // set the perSiteRecRate equal to 30 * perSiteMutRate 
	popSize = p;   // input p 
	
	rho = rhot;   //input rho total 
	envSD = e;   // input e 
	fitnessCost = f;    // input f
 	
	L = Ls + Ll;
   maxG = 2 * (Ls * betaS + Ll * betaL);
   threshold = maxG * rhot;
   offset = 4*envSD;
   startingPoint = 2 * Ls * rhoS - offset ; 	

 	// A and C are protective states for small effect and large effect 	   
   defineConstant('A_INIT',Ls * (1-rhoS) - offset/betaS);
   defineConstant('C_INIT',Ll);
   defineConstant('G_INIT',Ls * rhoS + offset/betaS);        
   defineConstant('T_INIT',0);        

 	// A, C, G, T
	initializeAncestralNucleotides(randomNucleotides(Ls+Ll, c(A_INIT, C_INIT, G_INIT, T_INIT))); // Ancestral allele start with protective 
 	

	// define constants
	defineConstant('MU',perSiteMutRate);
	defineConstant('REC',perSiteRecRate);
	defineConstant('N',popSize);
	defineConstant('RHO',rho);
	defineConstant('THR',threshold);
	defineConstant('START',startingPoint);
	defineConstant('FITCOST',fitnessCost);
	defineConstant('ENV_SIGMA',envSD);
	defineConstant('SAMPLE_INT', sampleInt);
	defineConstant('CYCLE', cyc);
	defineConstant('REP',rep);
	defineConstant('TOYRUN',toyRun);


	// output files
	defineConstant('FIXEDSMALLOUT',fixedSmallOut);
	defineConstant('FIXEDLARGEOUT',fixedLargeOut);
	defineConstant('MEANSMALLOUT',meanSmallOut);
	defineConstant('MEANLARGEOUT',meanLargeOut);
	defineConstant('MEANOUT',meanOut);
	defineConstant('H2OUT',h2Out);
	defineConstant('H2SOUT',h2sOut);
	defineConstant('H2LOUT',h2lOut);
	defineConstant('PREVOUT',prevOut);
	defineConstant('GENVAROUT',genVarOut);
	defineConstant('NSEGSMALLOUT',nSegSmallOut);
	defineConstant('NSEGLARGEOUT',nSegLargeOut);


	// liability mutations
	LiaMuts = initializeMutationTypeNuc("m1", 0.5, 'f', 0);
	LiaMuts.convertToSubstitution=T;
	
	// G and T are risk states for small effect and large effect 
	mutationMatrix = matrix(c(0,0, MU,0, 0,0,0,MU, MU,0,0,0, 0,MU,0,0), nrow=4, ncol=4);
	initializeGenomicElementType('g1', m1, 1.0, mutationMatrix);
	
	initializeGenomicElement(g1, 0, L-1);
	
	// set recombinationrate  
	initializeRecombinationRate(REC);
}


fitness(NULL){
	return (1.0 - FITCOST * asFloat(individual.tagF > THR)) * relFitness;
}


1 {
	sim.addSubpop('p1', N);
	sim.setValue("cycles", 0);
	sim.setValue("LfixedPos", NULL);  // record position fixed for risk allele
	sim.setValue("Nfixed", 0);   // record total number of fixed allele 
}


1:50000000 late() {
	thisGen=sim.generation;
	inds = sim.subpopulations.individuals;
	muts=sim.mutations;
	mutTypes=sim.mutationTypes;
	
	// count up substitutions
	subs=sim.substitutions.nucleotide;
	fixedSmallGenLi = 2 * betaS * (sum(subs=="G") - sum(subs=="A")); 
	fixedLargeGenLi = 2 * betaL * length(sim.getValue("LfixedPos"));
	fixedGenLi = fixedSmallGenLi + fixedLargeGenLi;

	if (length(subs)!= sim.getValue("Nfixed")){
	   for (newsubs in c((sim.getValue("Nfixed") +1): length(subs))){
	   	sim.setValue("Nfixed", sim.getValue("Nfixed") + 1);

	   	// the new substitution was a plus fix 
	   	if ((subs[newsubs-1] == "T")){
	      	   plus_pos = sim.substitutions[newsubs-1].position;
	      	   sim.setValue("LfixedPos", c(sim.getValue("LfixedPos"), plus_pos));
		   fixedLargeGenLi = fixedLargeGenLi  + 2 * betaL; 
		   fixedGenLi = fixedGenLi + 2 * betaL;
	   	   }

	   	// the new substitution was a minus fix
	   	if ((subs[newsubs-1] == "C")){
	      	   minus_pos = sim.substitutions[newsubs-1].position;
	      	   if (length(sim.getValue("LfixedPos")) !=0){
	      	      if (sum(minus_pos == sim.getValue("LfixedPos")) !=0){
		      	 
			 // When it is previously a fixed risk allel, fixed genetic liability -2  and take it out of the fixedPos list
			 fixedLargeGenLi = fixedLargeGenLi - 2*betaL; 
			 fixedGenLi = fixedGenLi - 2 * betaL;
		    	 old_fixedPos = sim.getValue("LfixedPos");
		    	 new_fixedPos = old_fixedPos[which(old_fixedPos !=minus_pos)];
		    	 sim.setValue("LfixedPos", new_fixedPos);
		      }
	           }
	        }	       
	   }	
	}

	Ninds = length(inds);

	// calculate the liability for the segregating sites 
	segGenLi = rep(0.0, Ninds);
	segGenLiLarge = rep(0.0, Ninds);
	segGenLiSmall = rep(0.0, Ninds);
	for (i in c(0:(Ninds-1))){
		ind_mut = sim.subpopulations.individuals[i].genomes.mutations.nucleotide;
		segGenLiSmall[i] = sum(ind_mut =="G") * betaS - sum(ind_mut =="A") * betaS;
		segGenLiLarge[i] = sum(ind_mut =="T") * betaL - sum(ind_mut =="C") * betaL;
		segGenLi[i] = segGenLiSmall[i] + segGenLiLarge[i]; 
	}

	// calculate components of genetic liability 
	fixedStateSmall = START + fixedSmallGenLi;
	fixedStateLarge = fixedLargeGenLi;	
	fixedState = fixedStateSmall + fixedStateLarge;
	genLi = fixedState + segGenLi;
	inds.tagF = genLi + rnorm(N, 0.0, ENV_SIGMA);
	
	// things to output
	mean=mean(genLi);
	meanSmall=mean(START + fixedSmallGenLi + segGenLiSmall);
	meanLarge=mean(fixedLargeGenLi + segGenLiLarge);	
	genVar=var(genLi);
	phenVar=var(inds.tagF);

	
	genVarSmall = var(fixedSmallGenLi + segGenLiSmall);
	genVarLarge = var(fixedLargeGenLi + segGenLiLarge);

	h2=genVar/phenVar;
	h2s = genVarSmall/phenVar; 
	h2l = genVarLarge/ phenVar; 

	prev=sum(inds.tagF>THR)/length(inds.tagF);

	nSegSmall = sum(sim.mutations.nucleotide=="A") + sum(sim.mutations.nucleotide=="G");
	nSegLarge = sum(sim.mutations.nucleotide=="C") + sum(sim.mutations.nucleotide=="T");
	
	if (sim.generation % 5000 ==0){print(sim.generation);}
	
	if (
		(sim.generation > 10*N & sim.generation % SAMPLE_INT ==0 & sim.getValue("cycles") < CYCLE & TOYRUN == 0) |
		(sim.generation < 10 & TOYRUN == 1)
	)
	{
	   writeFile(FIXEDSMALLOUT, paste(fixedStateSmall, sep=","), append=T);
	   writeFile(FIXEDLARGEOUT, paste(fixedStateLarge, sep=","), append=T);
		writeFile(MEANSMALLOUT, paste(meanSmall, sep=","), append=T);		
		writeFile(MEANLARGEOUT, paste(meanLarge, sep=","), append=T);				
		writeFile(MEANOUT, paste(mean, sep=","), append=T);
		writeFile(PREVOUT, paste(prev, sep=","), append=T);
		writeFile(H2OUT, paste(h2, sep=","), append=T);
		writeFile(H2SOUT, paste(h2s, sep=","), append=T);
		writeFile(H2LOUT, paste(h2l, sep=","), append=T);
		writeFile(GENVAROUT, paste(genVar, sep=","), append=T);
		writeFile(NSEGSMALLOUT, paste(nSegSmall, sep=","), append=T);
		writeFile(NSEGLARGEOUT, paste(nSegLarge, sep=","), append=T);
		sim.setValue("cycles", sim.getValue("cycles") +1);
	}
	else if (
		(sim.getValue("cycles") >= CYCLE) |
		(sim.generation >= 10 & TOYRUN == 1)
	)
	{
		sim.simulationFinished();
	}
}

